import Crypto
from Crypto.PublicKey import RSA
import numpy as np
import gmpy

c = 95272795986475189505518980251137003509292621140166383887854853863720692420204142448424074834657149326853553097626486371206617513769930277580823116437975487148956107509247564965652417450550680181691869432067892028368985007229633943149091684419834136214793476910417359537696632874045272326665036717324623992885
p = 11387480584909854985125335848240384226653929942757756384489381242206157197986555243995335158328781970310603060671486688856263776452654268043936036556215243
q = 12972222875218086547425818961477257915105515705982283726851833508079600460542479267972050216838604649742870515200462359007315431848784163790312424462439629
dp = 8191957726161111880866028229950166742224147653136894248088678244548815086744810656765529876284622829884409590596114090872889522887052772791407131880103961
dq = 3570695757580148093370242608506191464756425954703930236924583065811730548932270595568088372441809535917032142349986828862994856575730078580414026791444659

def chinese_remainder(c, p, q, dp, dq):
    m1 = pow(c, dp, p)
    m2 = pow(c, dq, q)
    qinv = gmpy.invert(q, p) 
    h = (qinv*(m1 - m2)) % p 
    m = m2 + h*q
    return m

if __name__=="__main__":
    print("Attempting to do the Chinese Remainder Theorem decryption")
    m1 = pow(c, dp, p)
    print("m1 (pow(c,dp,p)) = {0}".format(m1))
    m2 = pow(c, dq, q)
    print("m2 (pow(c,dq,q)) = {0}".format(m2))
    qinv = gmpy.invert(q, p) 
    print("qinv = gmpy.invert(q,p) = {0}".format(qinv))
    h = (qinv*(m1 - m2)) % p 
    print("h = qinc*(m1 - m2)) % p = {0}".format(h))
    m = m2 + h*q
    print("m = m2 + h*q =  {0}".format(m))
    m_hexstr = hex(m)

    for i in range(len(m_hexstr)/2):
        if i==0 or i==1:
            continue
        print(chr(int(m_hexstr[i:i+2],16)))

    # the above doesnt get it right. just use Crypto.Util.number's long_to_bytes
    from Crypto.Util.number import long_to_bytes
    m_txt = long_to_bytes(m)
    print(m_txt)
